package com.example.demo.learn.io;

/**
 * IO
 *  1、应用程序进程向操作系统发起IO调用请求
 *  2、操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区
 *  3、操作系统拷贝数据，将内核缓冲区的数据，拷贝到进程缓冲区
 *
 * @author hujiping
 * @date 2023/7/5 12:20 PM
 */
public class IoDemo {

    // 同步阻塞 BIO
    //  应用程序的进程发起IO调用，但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为阻塞IO

    // 同步非阻塞 NIO
    //  应用程序的进程发起IO调用，如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO
    //  应用程序发起IO调用，轮询的方式发送请求查询内核数据是否准备好，没准备好则返回错误信息给用户进程，让他不需要等待，准备好则将内核数据拷贝到用户进程缓冲区并返回成功提示。

    // IO多路复用（select、poll、epoll）
    //  NIO无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用。（非阻塞IO模型（NIO）中，需要N（N>=1）次轮询系统调用，然而IO多路复用模型，只需要发起一次系统调用就够了,大大优化了性能）
    //  IO复用模型核心思路：系统给我们提供一类函数（如select、poll、epoll函数），它们可以同时监控多个fd的操作，任何一个返回内核数据就绪，应用进程再发起recvfrom系统调用。
    //  epoll先通过epoll_ctl()来注册一个fd（文件描述符），一旦基于某个fd就绪时，内核会采用回调机制，迅速激活这个fd，当进程调用epoll_wait()时便得到通知。这里去掉了遍历文件描述符的坑爹操作，而是采用监听事件回调的的机制。这就是epoll的亮点。
    //  应用程序的进程发起IO调用，注册多个fd传给内核，内核一旦发现某个fd就绪时，则通过回调的方式通知应用程序（此时应用程序调用epoll_wait()时便得到通知）将数据从内核空间拷贝到应用空间。
    
    // 信号驱动模型
    //  应用进程发起IO调用时，向内核发送一个信号，然后应用进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知应用进程，应用进程收到信号之后，立即调用recvfrom，去读取数据。
    
    // 异步 AIO
    //  BIO，NIO和信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的，因此都不是真正的异步。
    //  应用进程发起IO调用时，立即返回处理结果。等内核数据准备好，将数据拷贝到用户进程缓冲区后发送信号通知用户进程IO操作执行完毕。
}
